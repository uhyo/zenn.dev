---
title: "派生atomの再読み込みとUIバージョニング"
---

前章では、非同期処理の状態管理（Promiseの管理）にjotaiの派生atomを使う方法を紹介しました。派生atomは一度計算されるとキャッシュされるため、同じPromiseを返し続けることができ、Suspenseと相性が良いのでしたね。

しかし、場合によっては再度非同期処理を実行して新しいPromiseを取得したいこともあります。例えば、ユーザープロフィールを表示するコンポーネントで「更新」ボタンを押したときに最新のプロフィール情報を取得したい場合です。これは典型的なユースケースですが、実装には少しの工夫と、考え方の転換が必要です。

この章では、再読み込みの実装の考え方を説明します。

## 再読み込みキーを使って再読み込みする

派生atomの再計算は、依存しているatomが変化したときにのみ行われます。したがって、再度非同期処理を実行したい場合は、**何かしらの依存先を変化させる**必要があります。

そこで、再読み込み用の「キー」を表すatomを用意します。このatomは単純に数値などを持っておき、再読み込みしたいときにその値を更新します。派生atomの中でこのキーatomを参照することで、キーが変化したときに派生atomが再計算され、非同期処理が再度実行されるようになります。

```tsx
const refetchKeyAtom = atom(0);

const userAtom = atom(async (get) => {
  get(refetchKeyAtom); // 再読み込みキーを参照
  const user = await fetchUser();
  return user;
});
```

このコードでは、`userAtom`が`refetchKeyAtom`を参照しています。これにより、jotaiは`refetchKeyAtom`の値が変化したときに`userAtom`を再計算します。`refetchKeyAtom`の値は特に使っていませんが、参照することで依存関係が作られます。

再読み込みを実行したいときは、`refetchKeyAtom`の値を更新します。例えば、以下のように「更新」ボタンのクリックハンドラで値をインクリメントすることができます。

```tsx
const ReloadButton: React.FC = () => {
  const setRefetchKey = useSetAtom(refetchKeyAtom);

  const handleReload = () => {
    setRefetchKey((key) => key + 1); // 再読み込みキーを更新してuserAtomを再評価させる
  };

  return (
    <button type="button" onClick={handleReload}>再読み込み</button>
  );
};
```

ここでは整数を用いましたが、真偽値でも可能です。`true`と`false`を交互に切り替えるだけでも再評価が行われます。

実際にこのようなボタンを設置して動作させると、ボタンを押すたびに`userAtom`が再計算され、最新のユーザープロフィール情報が取得されるようになります。再計算が始まった際には、`userAtom`の結果が新しいPromiseになるため、`userAtom`を読むコンポーネント（`UserProfile`）は再度サスペンドし、ローディング状態が表示されます。

### インターフェースを少し工夫する

上の例のような`handleReload`だと、再読み込みの仕組み（インクリメントされる数値を使うこと）が使用側に漏れすぎてしまっています。そこで、インターフェースを少し整えてみましょう。色々な方法がありますが、jotai流の方法として、再読み込みを発生させる書き込み専用atomを用意する方法があります。

```tsx
const reloadUserAtom = atom(null, (get, set) => {
  set(refetchKeyAtom, (key) => key + 1); // 再読み込みキーを更新してuserAtomを再評価させる
});
```

こうすると、`ReloadButton`は以下のようにシンプルになります。

```tsx
const ReloadButton: React.FC = () => {
  const reloadUser = useSetAtom(reloadUserAtom);

  const handleReload = () => {
    reloadUser(); // 再読み込みを発生させる
  };
  return (
    <button type="button" onClick={handleReload}>再読み込み</button>
  );
};
```

## 宣言的UIとの整合性

「再読み込みのために数値をインクリメントする」と言われてどう思ったでしょうか。「**すごい！　宣言的！**」と思いましたか？　それとも「**何それ無理やりすぎない？**」と思いましたか？

後者の方は、これはちょっと見た目が変わっただけで、従来のように「再読み込み関数」を呼び出しているのと本質的には変わらない、と思ったのかもしれません。

しかし、筆者としては、このようなやり方も宣言的UIの考え方と整合するものであると思っています。

まず、このやり方では、非同期処理の再実行（再読み込み）も、あくまで**ステート更新の結果**として発生しています。前章で説明したことの繰り返しになりますが、Suspenseでは**非同期処理もUIの計算の一部**であるため、非同期処理の再実行（派生ステート）もステート更新の結果として発生するべきなのです。

### Reactの思想とデータ取得

もうすこしReactの思想の話を深堀りしましょう。そもそも外部データの取得のような処理は、**純粋ではない**という問題があります。つまり、まったく同じ関数により計算（データ取得）を行っても、場合により結果が変わる可能性があるのです。

一方、Reactではデータ取得もUIの計算の一部であり、[UIの計算は“純粋”でなければならない](https://zenn.dev/uhyo/articles/react-pure-components)とされています。この2つをどう両立させるのでしょうか。

筆者の解釈では、再読み込みを実装する前の状況では**データ取得も“純粋”であるという暗黙の仮定**が置かれていました。だから、一度取得したデータをキャッシュして、そのあと何回レンダリングを行っても、そのキャッシュしたデータを「取得したデータ」として扱っていました。

言い換えると、ここではそもそも「取得したデータをキャッシュした」とすら考えていません。上記の暗黙の仮定のもと、「データ取得という計算」もUIの計算の一部であると扱っていると解釈できます。そして、**実装の側をそれに合わせているのです**。

つまり、React目線での考え方はこうです。

- データ取得もUIの計算の一部であり、UIの計算は純粋でなければならない。
- したがって、必然的にデータ取得も純粋な計算であり、同じパラメータに対しては同じ結果が得られるはずだ。 

そして、この**React目線に合わせた実装**が、データ取得結果のキャッシュということになります。前記の仮定のもと、Reactは再レンダリングのたびに「データ取得という計算」を毎回再実行していると考えていいのだけど、実装目線だと愚直にそれをやると毎回結果が変わってしまう（恐れがある）ので、キャッシュを駆使してReactの要望どおりにデータ取得が純粋かのように振る舞わせている、というわけです。

無茶な話に聞こえるかもしれませんが、Reactの思想、Suspense、そして宣言的UIに正面から向き合って考察すると、こういう解釈になります。そして、現代のReactでは実際に「キャッシュ」が重要な役割を果たしているのも事実です。それを思想の側から解釈するとこうなるということです。

### 再読み込みの導入

再読み込みを導入する場合、上記の暗黙の仮定が崩れるように思えます。再読み込みはそもそも「同じパラメータに対して異なる結果が得られうる」ということを前提にした概念だからです。

これを上記の解釈と整合するように導入したのが、この章で取り扱った「再読み込みキー」です。再読み込みキーを導入することで、**「同じパラメータに対して異なる結果が得られうる」のではなく、パラメータ自体が変化したと解釈できるようにした**のです。

つまり、再読み込みキーもデータ取得に対するパラメータの一部であると考えます。そうすると、再読み込みキーが変化したときにデータ取得のパラメータが変化したことになり、計算結果が変わっても問題なくなります。「同じパラメータに対して異なる結果が得られた（純粋ではない）」のではなく、「**パラメータが変化したから結果が変化した**」と考えることができ、データ取得は純粋な計算であるという解釈を壊さずにすみます。

これにより、再読み込みを導入しても、React目線での考え方と整合させることができるのです。

このような考え方は、純粋関数型言語で入出力ができる理屈に通ずるところがあると感じています。そう思うと、“純粋性”を大事にするReactの解釈としてそう突飛なものでもないように思えますね。

## UIバージョニング

筆者は個人的に、このようなやり方を「**UIバージョニング**」と呼んでいます。今回の例の`refetchKeyAtom`のようなものは、再読み込みのための無意味な数値ではなくUIの**バージョン**を表すものだと解釈するのです。

つまり、`refetchKeyAtom`の値を1から2に変えることは、「今はバージョン1のUIを表示しているが、バージョン2のUIを表示したい」という意味だと捉えます。そして、データ取得も「バージョンに依存する計算」の一部であると考えます。最初に取得したデータは「バージョン1のデータ」であり、再読み込み後に取得したデータは「バージョン2のデータ」になります。

なので、先ほど`refetchKeyAtom`は`true`/`false`でも問題ないと述べましたが、個人的には好きではありません。真偽値だと「バージョン」という解釈が難しいからです。`true`→`false`→`true`と変化したとき、最初のバージョンに戻ったように見えてしまいますが、実際にはこれは3つ目のバージョンなのです[^note_atom_cache]。

整数を使う方法だと、同じ整数に戻ってくることがないので、「バージョン」という解釈がしやすいですね[^note_safe_integer]。

[^note_atom_cache]: 非同期atomのキャッシュは1つだけなので、`true`→`false`になった時点で`true`時のキャッシュが破棄されます。そのため、再度`true`に戻ったときは古いキャッシュが再利用されるのではなく、新しく計算し直されます。

[^note_safe_integer]: 実際にはJavaScriptの整数の仕様上、整数を使うと2^53回（9007199254740992回）インクリメントした後は`+1`しても値が増えなくなりバージョン管理が破綻してしまうという問題があります。しかし、さすがに実用上問題になることはないでしょう。どうしても気になるのであればBigIntを使いましょう。

UIバージョニングの概念はReactの思想とも絡んでいるため、衒学的で不要な考え方に思われたかもしれません。しかし、UIバージョニングの考え方が重要になる場面も存在します。特に、Reactの外部とReactアプリケーションを接続するような場合です。これについては、また別の機会に説明したいと思います。

## まとめ

派生atomの再読み込みは、再読み込み用のキーatomを用意し、その値を更新することで実現できます。この方法は、Reactの思想や宣言的UIの考え方とも整合しています。再読み込みキーをUIのバージョンとして解釈することで、データ取得を純粋な計算として扱うという前提を保ちながら、非同期処理の再実行を実現できます。

## 練習問題

この章で学んだ再読み込みキーのパターンをユーティリティ関数として抽象化してみましょう。

以下のような`createReloadableAtom`関数を実装してください。この関数は読み取り専用派生atomを作るときの`atom`と同様に振る舞い、派生atomを作って返します。さらに、その派生atomを再読み込みできる手段を提供します。

```tsx
import { atom, type Getter } from "jotai";

function createReloadableAtom<T>(
  getter: (get: Getter) => T
) {
  ???
}
```

:::details 答え

```tsx
function createReloadableAtom<T>(
  getter: (get: Getter) => T
) {
  const refetchKeyAtom = atom(0);

  return atom(
    (get) => {
      get(refetchKeyAtom);
      return getter(get);
    },
    (get, set) => {
      set(refetchKeyAtom, (key) => key + 1);
    }
  );
}

// 使用例
const userAtom = createReloadableAtom(async () => {
  const user = await fetchUser();
  return user;
});

const UserProfile: React.FC = () => {
  // userAtomを読み取ってユーザー情報を取得
  const user = useAtomValue(userAtom);
  // userAtomに書き込んで再読み込みを発生させる
  const reloadUser = useSetAtom(userAtom);

  return (
    <section>
      <h1>{user.name}さんのプロフィール</h1>
      <button type="button" onClick={() => reloadUser()}>再読み込み</button>
    </section>
  );
};
```

ポイントは、読み書き両用のatomを返していることです。`atom`関数に2つの引数を渡すことで、読み取り関数と書き込み関数の両方を持つatomを作成できます。

読み取り関数では、内部で作成した`refetchKeyAtom`を参照しつつ、渡された`getter`を呼び出しています。書き込み関数では、`refetchKeyAtom`をインクリメントして再読み込みを発生させています。

`refetchKeyAtom`は`createReloadableAtom`関数のローカル変数として作成されるため、外部に露出しません。これにより、再読み込みの実装詳細を隠蔽しつつ、シンプルなインターフェースを提供できます。

### 別解: 2つのatomを返す方法

読み取り用と書き込み用のatomを別々に返す方法もあります。

```tsx
function createReloadableAtom<T>(
  getter: (get: Getter) => T
): {
  dataAtom: Atom<T>;
  reloadAtom: WritableAtom<null, [], void>;
} {
  const refetchKeyAtom = atom(0);

  const dataAtom = atom((get) => {
    get(refetchKeyAtom);
    return getter(get);
  });

  const reloadAtom = atom(null, (get, set) => {
    set(refetchKeyAtom, (key) => key + 1);
  });

  return { dataAtom, reloadAtom };
}
```

この方法は、読み取りと書き込みの責務を明確に分離したい場合に有用です。使用する側では`dataAtom`と`reloadAtom`を別々に扱うことになります。

:::

