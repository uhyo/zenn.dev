---
title: "Reactコンポーネントが「純粋である」とはどういうことか？　丁寧な解説"
emoji: "💎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react"]
published: false
---

Reactにおいては、コンポーネントは**純粋**であるべきだとされています。これはReactのルールの一部であり、ルールを守らずに非純粋なコンポーネントを作った場合、さまざまな不都合が発生します。

- 最適化（React Compiler）によって挙動が変わり、バグの原因となる
- Reactの新機能と互換性が無くなり、新機能の恩恵を受けられなくなる
- Reactのアップデートで壊れるかもしれない
- コードの可読性が低下し、保守性が悪化する

では、コンポーネントが **“純粋”** であるとは、具体的にどういうことを指すのでしょうか。Reactを使いこなしている人は経験的にこのことを理解していますが、正確に説明しろと言われると困る人も多いのではないでしょうか。

そこで、この記事では、Reactにおけるコンポーネントの**純粋性**についてなるべく丁寧に解説し、Reactにおける純粋性に関する様々な疑問を解決することを目指します。

## 最初に公式ドキュメントを見る

Reactの公式ドキュメントでも、コンポーネントは純粋であるべきだと説明されています。そのため、純粋とはどういうことかについても説明があります。

https://ja.react.dev/learn/keeping-components-pure

このコンポーネントでは具体例や平易な言葉を使ってわかりやすく純粋性について説明することが試みられており、とくに核心に迫る点を以下に引用します。

> コンピュータサイエンス（特に関数型プログラミングの世界）では、純関数 (pure function) とは、以下のような特徴を持つ関数のことを指します。
>
> - **自分の仕事に集中する。** 呼び出される前に存在していたオブジェクトや変数を変更しない。
> - **同じ入力には同じ出力。** 同じ入力を与えると、純関数は常に同じ結果を返す。

> React はこのような概念に基づいて設計されています。**React は、あなたが書くすべてのコンポーネントが純関数であると仮定しています。** つまり、あなたが書く React コンポーネントは、与えられた入力が同じであれば、常に同じ JSX を返す必要があります。

> React のレンダープロセスは常に純粋である必要があります。コンポーネントは JSX を*返す*だけであり、レンダー前に存在していたオブジェクトや変数を書き換えしないようにしなければなりません。さもなくばコンポーネントは不純 (impure) になってしまいます！

ここに書いてあることはもちろん間違いではありませんが、より多くの人が理解するためには、さらに行間を埋めてあげる必要があると考えています。

この記事では、公式ドキュメントを読んだ人や、特に読んでいないけど何となく経験的にReactにおける純粋性を理解している人に向けて、さらに丁寧な解説を提供することを目指します。

## 純粋性ってなに？

考察の第一歩として、**純粋**という言葉の意味をちゃんと考えましょう。

「純粋性」とは、本来関数が持つ性質です。「純粋な関数」とか、「純粋ではない関数」といった言い方をします。Reactにおいては、コンポーネントは関数であるため（クラスコンポーネントはここでは忘れましょう[^note_class_components]）、コンポーネントが純粋であるとは、おおよそ、そのコンポーネントを関数として見たときに純粋であることを指すでしょう。

[^note_class_components]: 純粋なコンポーネントという考え方をクラスコンポーネントにも拡張することはもちろん可能です。この記事では、そうしても説明をむやみに複雑にするだけで、関数コンポーネントだけ考えても十分本質を理解できる考え、クラスコンポーネントは脇に置いておくことにします。

では、純粋関数とは何でしょうか。これについてはReact特有の概念ではなく、どちらかというと関数型プログラミングのコミュニティのほうが知見が豊富でしょう。普通は、純粋関数とは、以下の2つの条件を満たす関数を指します。

- **副作用を含まない**。つまり、関数を実行した結果として、関数の外部に対して影響を与えないこと。
- **参照透過性を持つ**[^note_transparency]。つまり、同じ引数を与えたときに、常に同じ結果を返すこと。

[^note_transparency]: 正確には、参照透過性は「関数」ではなく「式」が持つ性質とされます。そのため、より正確に言えば、「その関数呼び出しの式が参照透過性を持つ」と言うべきかもしれません。

ただし、定義にもいろいろ流派があるようです。たとえば、「関数の外部から何らかの情報を読み取ること」を副作用に含むことにすれば、参照透過性は省略して「副作用を含まない」という条件だけで純粋関数を定義することもできるでしょう。

:::details 例: この関数は副作用を含むか？
```ts
function randInt(max: number): number {
  return Math.floor(Math.random() * max);
}
```

この関数は、明らかに参照透過性を持ちません。なぜなら、同じ引数を与えても、毎回異なる結果を返すからです。しかし、この関数が副作用を持つかどうかは、意見が分かれるところです。以下のような意見が考えられるでしょう。

1. 関数の外部に何かを書き込んでいないので、副作用は持たない。
2. `Math.random()`は関数外部から情報を関数内に取り込んでいるので、副作用を持つ。
3. そもそも`Math.random()`はその裏にいる疑似乱数生成器の状態を変更するので、副作用を持つのでは？

ただし、この記事では3のような考え方はしないことにします。`Math.random()`の呼び出しが裏で何らかの書き込みを伴うかどうかは、JavaScriptの言語仕様による抽象化の向こう側の世界の話であり、JavaScriptプログラムの純粋性の話をするときに考えなくてもいい領域だと思うからです。

`Math.random()`の他にも、`new Date()`なども同じような議論ができるでしょう。
:::

ここで、筆者が最近見かけた純粋性・副作用についての議論で、[納得感があった考え方](https://x.com/cubbit2/status/1918509054860902764)を紹介します。筆者の言葉で言い換えると、あらゆる場面で通用する「純粋性」の共通の定義を考えてもあまり意味がありません。そうではなく、具体的な場面で **「その関数が純粋だとなぜ嬉しいのか」**、言い換えると「なぜその関数が純粋かどうか知りたいのか」を考え、それに沿って純粋性を定義するのが良いだろうということです。

要するに、今回はReactコンポーネントの純粋性について考えているのですから、**「Reactの文脈での純粋性の定義」** のようなものを考えてもいいということです。もちろん限度はあります。React以外の分野でも使われている言葉を借りるのですから、あまり好き勝手にはできず、純粋性の共通認識をある程度尊重する必要はあるでしょう。

結局Reactのコンポーネントが純粋であるかどうかについては、基本的には上記のように「副作用を持たない」「参照透過性を持つ」という条件で考えて構いません。ただし、細かく考えていくと定義に調整が必要になってしまうので、それはのちのち説明していきます。ここで言いたかったことは、そのように「純粋性」の定義を調整することは別におかしいことではなく、むしろReactの文脈で「純粋性」の概念を効果的に運用するために必要なことだということです。

## 副作用の例

Reactコンポーネントでなければならないということは、すなわち副作用があってはいけないということです。ここで、Reactコンポーネントにおける副作用とは何なのかイメージを持つために、副作用を持つ（すなわち、だめな）コンポーネントの例をいくつか挙げてみましょう。

なお、ここからは外部から何かを読み取る（参照透過ではない）ことも副作用に含めて説明していきます。これはReact界隈ではこれも「副作用」に含めて説明されがちなことと、「副作用」と「参照透過性」の2つの用語を使い分けて説明するのが大変なことが理由です。

### 1. コンポーネントの外部に何かを書き込む

```tsx
let renderCount = 0;

const Counter: React.FC = () => {
  renderCount++;
  return <div>{renderCount}</div>;
};
```

この例は、かなり単純な副作用の例になっています。関数コンポーネントの処理内で、コンポーネントの外部にある変数`renderCount`をインクリメントしています。これが外部への書き込みです。

Reactの文脈でこれをやってはいけない理由は、この`Counter`という関数がいつ何回実行されるのかは、Reactの仕様として保証されていないからです。「`<Counter />`の中身が1回表示される＝`Counter`が1回実行される」といった単純な関係はReactでは成り立ちません。

最も単純に`render(<Counter />);`みたいに実行した場合は、さすがに1回な気がしますが、それも将来にわたって保証されるわけではありません。より複雑な次のような場合は、`<OtherComponent />`の挙動次第で`Counter`が複数回実行されるかもしれません。

```tsx
<Suspense>
  <Counter />
  <OtherComponent />
</Suspense>
```

このような場合、`Counter`が関数として何回実行されるかは、`Counter`の外部の要因によって左右されることになります。コンポーネントとしての`Counter`の仕様が外部要因に依存してしまっているのは、プログラムとして問題があるし、コンポーネントとして役に立ちません。

### 2. コンポーネントの外部から何かを読み取る

```tsx
const UserInfo: React.FC = () => {
  const userId = localStorage.getItem("userId");
  return <p>ユーザーID: {userId}</p>;
};
```

この例では、コンポーネントの外部（今回はlocalStorage）から何かを読み取っています。これも、コンポーネントの外部の状態に依存しているため、コンポーネントとしては不純です。

前述のように、Reactは`UserInfo`コンポーネントを表示するために、関数として`UserInfo`を何回も実行する可能性があります。そうなると、タイミング次第で`UserInfo`が表示する内容が変わってしまいます。こうなると、コンポーネントとしての仕様が曖昧になってしまうので良くありません。

### 3. 同じ入力でも結果が変わる

```tsx
const Lottery: React.FC = () => {
  if (Math.random() < 0.1) {
    return <p>当たり！</p>;
  } else {
    return <p>外れ</p>;
  }
};
```

2の亜種ですが、これも結局何回も実行したら結果が変わる恐れがあるので、純粋なコンポーネントとは言えません。

Reactは宣言的プログラミングのためのライブラリであり、コンポーネントの仕様を宣言的に記述することが求められます。入力以外の要因で結果が変わるようなコンポーネントは宣言的プログラミングの利点を破壊してしまうため、避ける必要があります。

### 4. ログを出力する

```tsx
const Logger: React.FC = () => {
  console.log("Logger");

  return <p>いい感じの表示内容</p>;
};
```

このように`console.log`でログを出力するのも副作用にあたります。とはいえ、フロントエンドの世界でこれをやるのはデバッグ中くらいでしょうから、デバッグ時にこれをやるなとは言いません。Reactではコンポーネントが関数としていつ何回実行されるかは保証されていないということを理解した上で、現状を把握するために使う分には問題ないでしょう。もちろん、デバッグが終わったら消すべきです。

### 5. ネットワークリクエストを行う

```tsx
const MyPage: React.FC<{ user: User }> = ({ user }) => {
  // マイページ表示時にページビューをサーバーに記録
  fetch('/api/log/pageview', {
    method: 'POST',
    body: JSON.stringify({ page: 'mypage', userId: user.id }),
  });

  return <section>
    <h1>マイページ</h1>
    ...
  </section>;
};
```

このようにネットワークリクエストを行うのも副作用にあたります。関数の外部に目に見える形で影響を与えていますからね。

「マイページを表示したときにページビューをサーバーに記録したい」と思った場合、そのタイミングを「`MyPage`関数が実行されたとき」と同一視してしまうと、1回ページを表示しただけなのに複数回リクエストが飛んでしまうといった現象に悩まされることになるでしょう。

## “同じ”とはどういうことか

ここから、Reactにおける純粋性の定義について、一段階掘り下げて考えていきます。

特に「外部から読み取る」系の副作用を持つコンポーネントは、同じ入力を与えたのに異なる結果を返してしまうことがあります。

裏を返せば、純粋なコンポーネントであるためには、同じ入力を与えたときに、常に **“同じ”** 結果を返す必要があるのです。

ここで考えたいのは、この「同じ」というのは、具体的にどういうことなのかということです。

JavaScriptプログラムにおいて、同じであることを判定する基本的な方法は`===`演算子を使うことです。

```ts
/** 10倍にする関数 */
function times10(x: number): number {
  return x * 10;
}

const a = times10(1);
const b = times10(1);

// 同じだ！
console.log(a === b); // true
```

しかし、Reactコンポーネントにおいては、`===`を使う考え方は通用しません。なぜなら、返り値（普通はJSX式の値）はオブジェクトだからです。

```tsx
const Hello: React.FC = () => {
  return <h1>Hello</h1>;
};

// 普通は関数コンポーネントをこのように直接呼び出しませんが、
// 今回は説明のために直接呼び出しています
const a = Hello();
const b = Hello();

// ===で比較しても同じにならない！
console.log(a === b); // false
```

この例で実際に`a`や`b`を確認してみると、このようなオブジェクトになっています（React 19の場合）。

```ts
{
  '$$typeof': Symbol(react.transitional.element),
  type: 'h1',
  key: null,
  props: { children: 'Hello' },
  _owner: null,
  _store: {}
}
```

このように、Reactのコンポーネントはオブジェクトを返すため、`===`で比較しても同じになりません。しかし、さすがにこの例の`Hello`は純粋なコンポーネントのはずです。そのため、Reactの文脈では`===`ではない別の考え方で「同じ」を判断することになります。

結論から言えば、Reactの文脈では、同じというのは大まかに「**意味が同じ**」という意味で考える必要があります。とはいえ、「意味が同じ」というのは抽象的すぎますので、なるべく理解の助けになるようにさらに説明します。

### JSX式はReactランタイムへの指示書である

典型的なReactコンポーネントは、このHelloコンポーネント（再掲）のように、JSX式を返します。

```tsx
const Hello: React.FC = () => {
  return <h1>Hello</h1>;
};
```

そして、`<h1>Hello</h1>`が具体的にどんな値になるのかというと、先ほど見たようなオブジェクトになります。これは我々が普段目にすることはあまりありませんが、Reactのランタイムはこのオブジェクトを受け取って動いています。JSX式の実態がこのようなオブジェクトであり、JSXという構文はそれをDOMに類似した形で直観的に表現するための糖衣構文であるということは、ぜひ理解しておきましょう。

このようなJSX式は、Reactのランタイムに対する指示書のようなものだと考えられます。つまり、Helloコンポーネントはこの返り値を通じて、「Helloコンポーネントをレンダリングするには、h1要素を作って、その中に"Hello"という文字列を入れなさい」という指示を出しているのです。こう考えると、“同じ”指示を出せばReactランタイムが同じ結果にしてくれることが期待できます。

つまり、Reactの文脈では、同じ指示を表すJSX式を毎回返すのであれば、コンポーネントは純粋であると考えることができます。

なお、現段階では、JSX式の同一性判定は「**ASTとして同じ**」という考え方も可能ではあります。この例の場合、`<h1>Hello</h1>`というJSX式は「h1という要素であり、その中に子要素としてHelloという文字列がある」という木になっていますから、木としての同一性を考えることもできるでしょう。抽象的な話より実装がどうなっているかの話のほうが分かりやすいという方は、基本的なメンタルモデルとして採用してもよいでしょう[^note_ast_equality]。

[^note_ast_equality]: 「現段階では」とか「基本的な」とかいって予防線を張っていることから分かるように、これはあくまでメンタルモデルの話です。実際のオブジェクトの対して同一性判定を実装することは、これくらい単純な状況ならできるでしょう。しかし、この先話がややこしくなってくるとどうしても実装が不可能な概念（関数の同一性）が出てきますので、100%実装ベースの理解がこの先通用するわけではないことはご理解ください。


## 副作用を書いていい場所、書いてはいけない場所

これまでの説明の通り、コンポーネントが純粋であるためには、副作用があってはいけません。しかし、実際にはReactアプリケーションには副作用が必要な場面もあります。そのような副作用を書く場所について、公式ドキュメントに立ち返ると、以下の記載があります。

> React では、**副作用は通常、イベントハンドラの中に属します**。イベントハンドラは、ボタンがクリックされたといった何らかのアクションが実行されたときに React が実行する関数です。イベントハンドラは、コンポーネントの「内側」で定義されているものではありますが、レンダーの「最中」に実行されるわけではありません！ つまり、**イベントハンドラは純粋である必要はありません**。

筆者の経験上、Reactにおける純粋性について理解しようとする際、ここの理解で躓く方が多いようです。そのため、この記事でも丁寧に解説します。

例えば、イベントハンドラが副作用を持つ例とは、以下のようなものです。

```tsx
const LoginButton: React.FC = () => {
  return (
    <button type="button" onClick={
      () => {
        // ログイン処理
        fetch("/api/login", {
          method: "POST",
          body: JSON.stringify({ username: "user", password: "pass" }),
        }).then((response) => {
          // 省略
        }).catch((error) => {
          // 省略
        });
      }
    }>
      ログイン
    </button>
  );
};
```

この例では、ログインボタンを押すとネットワークリクエストという副作用が発生します。これは、ボタンのclickイベントに対するイベントハンドラの中で行われています。つまり、公式ドキュメントの教えのとおり、イベントハンドラの中で副作用を実行しています。

重要な点として、この例の**LoginButtonコンポーネントは、Reactのルール上全く問題ない純粋なコンポーネントである**ということです。

字面だけ見るとコンポーネントの返り値（JSX式）の中にがっつりfetchとか書いてありますが、それでもこれは、副作用のあるコンポーネントとは見なされません。一見すると、Reactコンポーネントの中に、副作用を書いていい場所と書いてはいけない場所があるように見えてややこしいですね。

一言で理屈を説明するなら、コンポーネントの純粋性は「**返り値の計算**に副作用が含まれてはいけない」ことだと説明できます。つまり、ボタンのイベントハンドラの中は返り値の計算ではないので、副作用があってもいいということです。

別の言い方として、先ほどの「指示書」の考え方を使ってみましょう。この場合、LoginButtonコンポーネントが出す指示とは、「ボタンを表示する。そのボタンをクリックしたら**この関数**を実行する」というものです。 **この関数**が毎回同じものであるという前提なら、何回LoginButtonコンポーネントを実行しても、得られる指示は実質的に毎回同じになることが分かります。

説明のために、少しLoginButtonコンポーネントを書き換えて、イベントハンドラを変数に入れてみましょう。

```tsx
const LoginButton: React.FC = () => {
  const handleClick = () => {
    // ログイン処理
    fetch("/api/login", {
      method: "POST",
      body: JSON.stringify({ username: "user", password: "pass" }),
    }).then((response) => {
      // 省略
    }).catch((error) => {
      // 省略
    });
  };

  return (
    <button type="button" onClick={handleClick}>
      ログイン
    </button>
  );
};
```

JavaScriptでは関数は関数オブジェクトであり、関数式（`() => { ... }`）は新しい関数オブジェクトを生成します。つまり、上記のLoginButtonコンポーネントは、（返されるJSX式の結果がオブジェクトとしては毎回`===`ではないのと同様に）ボタンのイベントハンドラとして毎回異なる関数オブジェクトを返すことになります。

LoginButtonコンポーネントが2回実行されたとき、1回目の実行結果に含まれる`handleClick`と2回目の実行結果に含まれる`handleClick`は、`===`で比較すると同じではありません。しかし、どちらも実行したときの挙動はまったく同じですから、やはり「**意味が同じ**」なのです[^note_function_equality]。

[^note_function_equality]: 別々に作られた2つの関数が「同じ」であるとはどういうことか？　というのもまた、関数型プログラミング等の文脈でも取り扱われる奥の深い話題です。しかし、筆者もそこまで詳しくない上にReactの文脈ではそこまで重要な話でもないので、ここではお茶を濁して「実行したときの挙動がまったく同じだから意味が同じ」のようなちょっと抽象的な説明に留めておきます。

この「意味が同じ」であることを根拠に、LoginButtonコンポーネントは純粋なコンポーネントであると扱われます。具体的に言うなら、2つの`handleClick`を`handleClick1`, `handleClick2` と呼ぶことにすると、LoginButtonコンポーネントが返した1回目の指示は「ボタンを表示する。そのボタンがクリックされた場合は`handleClick1`を実行する」であり、2回目の指示は「ボタンを表示する。そのボタンがクリックされた場合は`handleClick2`を実行する」というものになります。ここで、`handleClick1`と`handleClick2`は意味が同じなので、結果的にLoginButtonが返した2回の指示は意味が同じとなります。そのため、LoginButtonコンポーネントは純粋なコンポーネントであると考えられるのです。

以上のように、「副作用を書いていい場所と書いてはいけない場所がある」というのがややこしければ、「指示書の意味」に注目するのが効果的です。コンポーネントの返り値として得られる指示書（JSX式の値）が、同じ入力に対しては同じ意味の指示書が返るのであれば、コンポーネントは純粋であると考えることができます。「意味が同じ」というのがいまいち抽象的な概念にはなってしまいますが、Reactコンポーネントが純粋かどうかを人間が判断する助けにはなるでしょう。

### 余談: 本当に“同じ”にするのは最適化のため

ReactはuseMemoやuseCallbackを使った経験がある方も多いでしょう。これらは、Reactコンポーネントにおいて扱われるデータを、本当に（`===`の意味で）同じにするために使われます。

例えば、LoginButtonコンポーネントをちょっと変えて`onLogin`をpropsとして受け取るようにしてみましょう。さらに、`React.memo`でラップして、LoginButtonコンポーネントが同じpropsを受け取ったときに再レンダリングしないようにします。

```tsx
const LoginButton: React.FC<{ onLogin: () => void }> = React.memo(({ onLogin }) => {
  return (
    <button type="button" onClick={onLogin}>
      ログイン
    </button>
  );
});
```

ちなみに、このように実装したLoginButtonコンポーネントはもちろん純粋なコンポーネントです。なぜなら、受け取った`onLogin`の意味が同じであれば、LoginButtonから得られる指示書も（意味が同じという意味で）同じになるからです。

では、LoginButtonを使う側のコンポーネントを考えてみましょう。

```tsx
const App: React.FC = () => {
  const handleLogin = () => {
    // ログイン処理
  };

  return <LoginButton onLogin={handleLogin} />;
};
```

このままでもAppは純粋コンポーネントですが、実際には`React.memo`を活かすために、useCallbackを使ってこのように実装されるでしょう。

```tsx
const App: React.FC = () => {
  const handleLogin = useCallback(() => {
    // ログイン処理
  }, []);

  return <LoginButton onLogin={handleLogin} />;
};
```

このようにuseCallbackを使うと、Appが複数回レンダリングされる場合、`handleLogin`は真の意味で“同じ”関数オブジェクトになります（つまり、`===`で比較しても同じになります）。

ここでuseCallbackをわざわざ使う理由は、ReactランタイムがLoginButtonコンポーネントを再レンダリングする必要があるかどうか判断する際の挙動にあります。理想的には、`onLogin`として渡されてきた関数が「同じ意味」のものであれば、LoginButtonコンポーネントは再レンダリングする必要がありません。しかし、プログラム上で2つの関数が「同じ意味」かどうか判定することはできません。そのため、ある種の次善策として、`===`で比較して「同じ」かどうかを判定するのです。

逆に言えば、Reactランタイムが、複数の関数が「同じ」かどうか判断するのを助けるために、「意味が同じ」関数をちゃんと`===`で同じにしてあげるのが、useCallbackの役割です。Reactのルール的には関数が「意味が同じ」であれば問題ありませんので、useCallbackを使うのはReactのルールを守るためとかではなく、あくまでパフォーマンス最適化のためです。

ちなみに、「理想的には」と書きましたが、実はその理想を実現してくれるものがあります。それが[React Compiler](https://ja.react.dev/learn/react-compiler)です。React Compilerは大まかに言えば「ビルド時の処理で、useCallbackなどをいい感じに自動的に差し込んでくれるもの」です[^note_react_compiler]。ランタイムに2つの関数が「意味が同じ」か判定することはできませんが、ビルド時に判定することはある程度可能です。そのため、React Compilerを使うと、我々がuseCallbackなどを使わなくても「意味が同じ」関数やオブジェクトが実際に`===`で同じになるように、React Compilerが自動的にプログラムを変換してくれます。

[^note_react_compiler]: 実際の変換結果はuseCallbackなどがそのまま使われているわけではなく、もうちょっと違う仕組みで動いています。しかし、大まかな理解としてはそのように理解しておけば大丈夫でしょう。正確に知りたい方は、React Compilerの仕組みを調べてみましょう。
